package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/jsr-probitas/dockerfiles/echo-graphql/graph/model"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// CreateMessage creates a new message
func (r *mutationResolver) CreateMessage(ctx context.Context, text string) (*model.Message, error) {
	r.mu.Lock()
	id := strconv.Itoa(r.nextID)
	r.nextID++
	msg := &model.Message{
		ID:        id,
		Text:      text,
		CreatedAt: time.Now().Format(time.RFC3339),
	}
	r.messages[id] = msg
	r.mu.Unlock()

	r.Broadcast(msg)
	return msg, nil
}

// UpdateMessage updates an existing message
func (r *mutationResolver) UpdateMessage(ctx context.Context, id string, text string) (*model.Message, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	msg, ok := r.messages[id]
	if !ok {
		return nil, &gqlerror.Error{
			Message: "message not found",
			Extensions: map[string]interface{}{
				"code": "NOT_FOUND",
				"id":   id,
			},
		}
	}

	msg.Text = text
	return msg, nil
}

// DeleteMessage deletes a message and returns true if it existed
func (r *mutationResolver) DeleteMessage(ctx context.Context, id string) (bool, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	_, ok := r.messages[id]
	if ok {
		delete(r.messages, id)
	}
	return ok, nil
}

// Echo echoes back the input message
func (r *queryResolver) Echo(ctx context.Context, message string) (string, error) {
	return message, nil
}

// EchoWithDelay echoes back the input message after a delay
func (r *queryResolver) EchoWithDelay(ctx context.Context, message string, delayMs int) (string, error) {
	select {
	case <-time.After(time.Duration(delayMs) * time.Millisecond):
		return message, nil
	case <-ctx.Done():
		return "", ctx.Err()
	}
}

// EchoError always returns an error with code INTENTIONAL_ERROR
func (r *queryResolver) EchoError(ctx context.Context, message string) (string, error) {
	return "", &gqlerror.Error{
		Message: message,
		Extensions: map[string]interface{}{
			"code": "INTENTIONAL_ERROR",
		},
	}
}

// EchoPartialError returns partial data with errors for messages containing "error"
func (r *queryResolver) EchoPartialError(ctx context.Context, messages []string) ([]*model.EchoResult, error) {
	results := make([]*model.EchoResult, len(messages))
	for i, msg := range messages {
		if strings.Contains(strings.ToLower(msg), "error") {
			errMsg := "message contains 'error'"
			results[i] = &model.EchoResult{
				Error: &errMsg,
			}
		} else {
			results[i] = &model.EchoResult{
				Message: &msg,
			}
		}
	}
	return results, nil
}

// EchoWithExtensions echoes back the message and adds custom extensions
func (r *queryResolver) EchoWithExtensions(ctx context.Context, message string) (string, error) {
	start := time.Now()
	graphql.RegisterExtension(ctx, "timing", map[string]interface{}{
		"startTime": start.Format(time.RFC3339Nano),
		"duration":  "0ms",
	})
	graphql.RegisterExtension(ctx, "tracing", map[string]interface{}{
		"version":   1,
		"requestId": fmt.Sprintf("req-%d", time.Now().UnixNano()),
	})
	return message, nil
}

// MessageCreated subscribes to message creation events
func (r *subscriptionResolver) MessageCreated(ctx context.Context) (<-chan *model.Message, error) {
	ch := r.Subscribe()

	go func() {
		<-ctx.Done()
		r.Unsubscribe(ch)
	}()

	return ch, nil
}

// Countdown counts down from the given number
func (r *subscriptionResolver) Countdown(ctx context.Context, from int) (<-chan int, error) {
	ch := make(chan int)

	go func() {
		defer close(ch)
		for i := from; i >= 0; i-- {
			select {
			case <-ctx.Done():
				return
			case ch <- i:
				if i > 0 {
					time.Sleep(time.Second)
				}
			}
		}
	}()

	return ch, nil
}

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
